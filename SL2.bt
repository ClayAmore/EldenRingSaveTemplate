//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: SL2
//   Authors: ClayAmore
//   Version: 
//   Purpose: Reading an Elden Ring Save File
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

local enum Boolean {
    False = 0,
    True = 1
};

// Coordinates
typedef struct {
    float X;
    float Y;
    float Z;
} FloatVector3 <read=Str("(%.1f, %.1f, %.1f)", X, Y, Z)>;

typedef struct {
    float X;
    float Y;
    float Z;
    float W;
} FloatVector4 <read=Str("(%.1f, %.1f, %.1f, %.1f)", X, Y, Z, W)>;

// MapID
typedef byte M[4] <read=Str("%02d %02d %02d %02d",this[3],this[2],this[1],this[0])>;

// Items 
// Global CS::GaItem starts at (143ce0680 + 0x8)
// Length 0x1400
// Used for lookup of item ids from ga_item_handle maybe
// Ashes of War are first
typedef struct Item {
    int32 GaitemHandle<format=hex>;
    Assert(
        (GaitemHandle & 0xF0000000) == 0 ||
        (GaitemHandle & 0xF0000000) == 0x80000000 ||
        (GaitemHandle & 0xF0000000) == 0x90000000 ||
        (GaitemHandle & 0xF0000000) == 0xC0000000
    );
    int32 ItemID<format=hex>;
    Assert(
        (ItemID == 0xFFFFFFFF) ||
        (ItemID & 0xF0000000) == 0 ||
        (ItemID & 0xF0000000) == 0x10000000 ||
        (ItemID & 0xF0000000) == 0x80000000
    );
    // Additional data for type = Weapon
    if ((GaitemHandle != 0) && ((GaitemHandle & 0xf0000000) == 0x80000000)) { 
        int32 unk0x10; 
        int32 unk0x14;
        uint32 AOWGaitemHandle<format=hex>;
        Assert(
            AOWGaitemHandle == 0 ||
            (AOWGaitemHandle & 0xF0000000) == 0xC0000000
        );
        byte unk0x1c; Assert(unk0x1c == 0);
    }
    // Additional data for type = Armor
    else if((GaitemHandle != 0) && ((GaitemHandle & 0xf0000000) == 0x90000000)) { 
        int32 unk0x10; 
        int32 unk0x14;
    }
};

// Player Game Data
// CS::PlayerGameData+0x8
// Length 0x1B0
typedef struct {
    uint32 unk0x0 <hidden = true>;
    uint32 unk0x4 <hidden = true>;
    uint32 Health;
    uint32 MaxHealth;
    uint32 BaseMaxHealth;
    uint32 FP;
    uint32 MaxFP;
    uint32 BaseMaxFP;
    uint32 unk0x20 <hidden = true>;
    uint32 SP;
    uint32 MaxSP;
    uint32 BaseMaxSP;
    uint32 unk0x30 <hidden = true>;
    uint32 Vigor;
    uint32 Mind;
    uint32 Endurance;
    uint32 Strength;
    uint32 Dexterity;
    uint32 Intelligence;
    uint32 Faith;
    uint32 Arcane;
    uint32 unk0x54 <hidden = true>;
    uint32 unk0x58 <hidden = true>;
    uint32 unk0x5C <hidden = true>;
    uint32 Level;
    uint32 Souls;
    uint32 Soulmemory;
    uint32 unk0x6c <hidden = true>;
    uint32 PoisonBuildUp;
    uint32 RotBuildUp;
    uint32 BleedBuildUp;
    uint32 FrostBuildUp;
    uint32 DeathBuildUp;
    uint32 SleepBuildUp;
    uint32 MadnessBuildUp;
    uint32 unk0x8c ;
    uint32 CharacterType;
    wchar_t  CharacterName[0x10];
    uint16 Terminator;
    byte Gender;
    byte ArcheType;
    byte unk0xb8 ;
    byte unk0xb9 ;
    byte VoiceType;
    byte Gift;
    byte unk0xbc ;
    byte unk0xbd ;
    byte AdditionalTalismanSlotsCount;
    byte SummonSpiritLevel;
    byte unk0xbf[0x18] ;
    byte FurlCallingFingerOn;
    byte unk0xd9 ;
    byte MatchmakingWeaponLvl;
    byte WhiteCipherRingOn;
    byte BlueCipherRingOn;
    byte unk0xdd[0x1A] ;
    byte GreatRuneOn;
    byte unk0xf8 ;
    byte MaxCrimsonFlaskCount;
    byte MaxCeruleanFlaskCount;
    byte unk0xfb[0x15] ; 
    wchar_t Password[0x9];
    wchar_t GroupPassword1[0x9];
    wchar_t GroupPassword2[0x9];
    wchar_t GroupPassword3[0x9];
    wchar_t GroupPassword4[0x9];
    wchar_t GroupPassword5[0x9];
    byte unk0x17c[0x34];
} PlayerGameData;

// Player Game Data
// CS::PlayerGameData+0x1B8
// Length 0xD0
typedef struct {
    uint32 SPEffectID;
    float RemainingTime;
    uint32 unk0x8;
    uint32 unk0x10;
} SPEffects;


// Equip Game Data
// CS::EquipGameData+0x8
// Length 0x58
typedef struct {
    uint32 LeftHandArmament1;
    uint32 RightHandArmament1;
    uint32 LeftHandArmament2;
    uint32 RightHandArmament2;
    uint32 LeftHandArmament3;
    uint32 RightHandArmament3;
    uint32 Arrows1;
    uint32 Bolts1;
    uint32 Arrows2;
    uint32 Bolts2;
    uint32 unk0x28 <hidden = true>;
    uint32 unk0x2c <hidden = true>;
    uint32 Head;
    uint32 Chest;
    uint32 Arms;
    uint32 Legs;
    uint32 unk0x40 <hidden = true>;
    uint32 Talisman1;
    uint32 Talisman2;
    uint32 Talisman3;
    uint32 Talisman4;
    uint32 unk0x54 <hidden = true>;
} ChrAsmEquipment;


// ChrAsm
// ChrAsm + 0x4
// Length 0x1C
typedef struct {
    uint32 ArmStyle;
    uint32 LeftHandWeaponActiveSlot;
    uint32 RightHandWeaponActiveSlot;
    uint32 LeftArrowActiveSlot;
    uint32 RightArrowActiveSlot;
    uint32 LeftBoltActiveSlot;
    uint32 RightBoltActiveSlot;   
} ArmStyleAndActiveWeaponSlots;


// Equip Inventory Data
// One for held inventory and one for storage box
// CS::EquipInventoryData+0x8
// Length 
typedef struct {
    uint32 GaitemHandle <format=hex>;
    uint32 Quantity;
    uint32 InventoryIndex;
} EquipInventoryDataEntry;

typedef struct (int commonItemsCapacity, int keyItemsCapacity) {
    uint32 CommonItemsCount;
    EquipInventoryDataEntry CommonItems[commonItemsCapacity] <read=Str("[%X, %d]", this.GaitemHandle, this.Quantity)>;
    uint32 KeyItemsCount;
    EquipInventoryDataEntry KeyItems[keyItemsCapacity] <read=Str("[%X, %d]", this.GaitemHandle, this.Quantity)>;;
    uint32 EquipIndexCounter;
    uint32 AcquistionIndexCounter;
} Inventory;


// Equip Magic Data
// EquipMagicData+0x10
typedef struct {
    int32 SpellID;
    int32 unk0x4;
} SpellSlot;
typedef struct {
    // Max is 12. Moon Of Nokstella Talisman adds two additional spots 
    SpellSlot SpellSlots[0xC] <read=Str("%d", this.SpellID)>;
    uint32 unk0x60 <hidden = true>;
    uint32 unk0x64 <hidden = true>;
    uint32 unk0x68 <hidden = true>;
    uint32 unk0x70 <hidden = true>;
    int32 ActiveIndex;
} EquipMagicData;


// Equip Item Data
// CS::EquipItemData+8
typedef struct {
    uint32 GaitemHandle <format=hex>;
    int32 EquipmentIndex;
} EquippedItem;
typedef struct {
    EquippedItem EquippedItems[0xA];
    uint32 ActiveSlot;
    EquippedItem PouchItems[0x6];
    uint32 unk0x0 <hidden = true>;
    uint32 unk0x0 <hidden = true>;
} EquipItemData;


// Gesture Equip Data
// CS::GestureEquipData+8 (7FF4A029D040+0x8)
// Length 0x70
typedef struct {
    uint32 EquippedGesture[0x6] <format = hex>;
} GestureEquipData ;


// Projectile Equip Data
// No class name (7FF49F546020)
// Length ProjectCount*0x8
typedef struct {
    int32 ItemID; // Can be found in the EquipParamWeapon.
    int32 unk0x4 <hidden = true>;
} Projectile;
typedef struct {
    uint32 ProjectileCount;
    Projectile Projectiles[ProjectileCount] <read=Str("%d", this.ItemID)>; 

} EquipProjectileData ;

// Another Equip Data list?
// Length 0x27*4
typedef struct {
    int32 LeftHandArmament1 <format=hex>;
    int32 RightHandArmament1 <format=hex>;
    int32 LeftHandArmament2 <format=hex>;
    int32 RightHandArmament2 <format=hex>;
    int32 LeftHandArmament3 <format=hex>;
    int32 RightHandArmament3 <format=hex>;
    int32 Arrows1 <format=hex>;
    int32 Bolts1 <format=hex>;
    int32 Arrows2 <format=hex>;
    int32 Bolts2 <format=hex>;
    int32 unk0x28 <format=hex, hidden = true >;
    int32 unk0x2c <format=hex, hidden = true>;
    int32 Head <format=hex>;
    int32 Chest <format=hex>;
    int32 Arms <format=hex>;
    int32 Legs <format=hex>;
    int32 unk0x40 <format=hex, hidden = true>;
    int32 Talisman1 <format=hex>;
    int32 Talisman2 <format=hex>;
    int32 Talisman3 <format=hex>;
    int32 Talisman4 <format=hex>;
    int32 unk0x54 <format=hex, hidden = true>; 
    int32 QuickItem1 <format=hex>;
    int32 QuickItem2 <format=hex>;
    int32 QuickItem3 <format=hex>;
    int32 QuickItem4 <format=hex>;
    int32 QuickItem5 <format=hex>;
    int32 QuickItem6 <format=hex>;
    int32 QuickItem7 <format=hex>;
    int32 QuickItem8 <format=hex>;
    int32 QuickItem9 <format=hex>;
    int32 QuickItem10 <format=hex>;
    int32 Pouch1 <format=hex>;
    int32 Pouch2 <format=hex>;
    int32 Pouch3 <format=hex>;
    int32 Pouch4 <format=hex>;
    int32 Pouch5 <format=hex>;
    int32 Pouch6 <format=hex>;
    int32 unk0x98 <format=hex, hidden = true>;
} EquippedArmamentsAndItems <size=(0x27*0x4)>;

// Equipped Physic
// No class name (7FF49FC3AD44)
// Length 0xC
typedef struct {
    int32 Slot1;
    int32 Slot2;
    int32 unk0x8;
} PhysicEquipData <size=0xC>;

// Face Data
// CS::FaceData
// Length 0x12F
typedef struct {
    int32 unk0x0 <hidden = true>;
    char magic[4] <hidden = true>;
    Assert(magic == "FACE");
    byte face_data_0x8[0x11c];
    byte face_data_0x128_not_eq_0x0 <hidden = true>; 
    int16 face_data_0x128 <hidden = true>;
    int64 face_data_0x12a <hidden = true>;
} FaceData <size=0x12F>;

// Gesture Game Data
// CS::GestureGameData (7FF49E380440)
// Length 0x100
typedef struct {
    int32 GestureID[0x40];
} GestureGameData;

// Regions
// No class name (7FF49FC3AFE8)
// Length: Length defined in the struct
typedef struct {
    uint32 RegionsCount;
    if (RegionsCount > 0) {
        uint32 RegionsIds[RegionsCount];
    }
} Regions;

// Ride Game Data
// CS::RideGameData (7FF4A05AC380)
// Length 0x28
local enum HorseState { Active = 13, InActive = 1, Dead = 3};
typedef struct {
    FloatVector3 Coordinates;
    M MapId;
    FloatVector4 Angle;
    int32 HP;
    HorseState State;
} RideGameData <size=0x28>;

typedef struct {
    FloatVector3 Coordinates;
    FloatVector4 Angle;
    uint32 unk0x1C <hidden = true>;
    uint32 unk0x20 <hidden = true>;
    uint32 unk0x24 <hidden = true>;
    uint32 unk0x28 <hidden = true>;
    uint32 unk0x2C <hidden = true>;
    int unk0x30  <hidden = true>;
    int Souls;
    M MapID;
    uint32 unk0x3C <hidden = true>;
    uint32 unk0x38 <hidden = true>; // Some sort of smaller map identifier.
} BloodStainData;

// Menu Profile Save Load
// CS::MenuProfileSaveLoad
// const CS::CSMenuSimpleSaveDataChunk<1,struct CS::MENU_WORLD_MAP_SAVEDATA,2>
// Length 0x1008
typedef struct {
    uint16 unk0x0 <hidden = true>;
    uint16 unk0x2 <hidden = true>;
    uint32 Size;
    byte Data[Size];
} MenuProfileSaveLoad <size=0x1008>;


// Trophy Equip Data
// CS::TrophyEquipData
// Length 0x34
typedef struct {
    int32 unk0x0;
    byte unk0x4[0x10];
    byte unk0x14[0x10];
    byte unk0x24[0x10];
} TrophyEquipData;


// Gaitem Game Data
// CS::GaitemGameData
// Length ((0x1B58*0x10)+0x8)
typedef struct  {
    uint32 id <read = Str("%d", this & 0x0fffffff)>;
    byte unk0x4 <hidden = true>;
    byte padding[3] <hidden = true>;
    uint32 NextItemId  <read = Str("%d", this & 0x0fffffff)>;
    byte unk0xc <hidden = true>;
    byte pading[3] <hidden = true>;
} GaitemGameDataEntry <read=Str("%d", id & 0x0fffffff)>;
typedef struct {
    int64 Count;
    GaitemGameDataEntry item[0x1B58];
} GaitemGameData;


typedef struct(int TotalSize) {
    uint32 Count;
    uint32 ID[TotalSize];
} CSTutorialDataChunk;
// Tutorial Data
// CS::CSTutorialData
// const CS::CSMenuSimpleSaveDataChunk<1,struct CS::MENU_WORLD_MAP_SAVEDATA,2>
// Length 0x408
typedef struct {
    uint16 unk0x0 <hidden = true>;
    uint16 unk0x2 <hidden = true>;
    uint32 Size;
    CSTutorialDataChunk Data(Size);
} CSTutorialData <size = (1024 + 8)>;


// EventFlag
// CS::CSFDVirtualMemoryFlag (7FF4A0300000)
// Length 0x1BF99F
typedef struct {
    byte Bit0: 1;
    byte Bit1: 1;
    byte Bit2: 1;
    byte Bit3: 1;
    byte Bit4: 1;
    byte Bit5: 1;
    byte Bit6: 1;
    byte Bit7: 1;
} EventFlag;


typedef struct {
    int32 Size;
    if (Size > 0) {
        uint32 Data[Size/4];
    }
} CSFieldArea;

typedef struct (int &pSize) {
    char magic[4];
    M MapId;
    uint32 Size;
    uint32 unk0xC <format = hex>;
    
    local int Size2 = Size - 0x10;
    Printf("%d\n", Size2);
    if (Size2 > 0 ) {
        byte unk0x8 [Size2];
        pSize = pSize - Size;
    }
    else {
        pSize = pSize - 0x10;
    }
} CSWorldBlockChrData <optimize = false>;
// TODO: Check if it changes during online session.
typedef struct (int32 Size) {
    char Magic[4];
    
    // Appears to be hardcoded to `0x21042700`. 
    uint32 unk_0x21042700 <hidden = true>;
    Assert(unk_0x21042700 == 0x21042700 || unk_0x21042700 == 0);
    
    uint32 unk0x8 <hidden = true>;
    Assert(unk0x8 == 0);
    
    uint32 unk0xc <hidden = true>;
    Assert(unk0xc == 0);
    
    if (Size != 0) {
        Size = Size - 0x10;
        while (Size != 0) {
            CSWorldBlockChrData WorldBlockChrData(Size);
        }
    }
} CSWorldAreaChrData;
typedef struct {
    int32 Size;
    if ( Size > 0 ) {
        CSWorldAreaChrData WorldAreaChrData (Size);
    }
} CSWorldArea;

// TODO: Clean up
typedef struct (int &S) {
    M MapID;
    uint32 Size;
    if ((Size - 8) > 0) {
        byte Data[Size-8];
    }
    S = S - Size;
} EntryData <optimize = false>;

typedef struct (int &Size) {
    char magic[4];
    uint32 unk0x4 <format = hex>;
    Size = Size - 20;
    while (Size > 0) {
        EntryData Entry(Size);
    }
    uint64 unk0xxx <hidden = true>;
    uint64 unk0xxx <hidden = true>;
} CSSomething;
typedef struct {
    int32 Size;
    local int S = Size - 4;
    if (S > 0) {
        CSSomething Data (S);
    }
} CSWorldGeomMan;


typedef struct (int Size) {
    byte Data[Size];
} CSStageManEntry <optimize = false>;
typedef struct (int &Size) {
    int Count;
    CSStageManEntry Entry((Size-4)/Count)[Count];
} CSStageMan;
typedef struct {
    int32 Size;
    if (Size > 0) {
        CSStageMan Data(Size);
    }
} CSRendMan;


// PlayerCoords
// Length 0x3D
typedef struct {
    FloatVector3 Coordinates;
    M MapID;
    FloatVector4 Angle;
    byte game_man_0xBF0 <hidden = true>;
    Assert(game_man_0xBF0 == 0 || game_man_0xBF0 == 1);
    FloatVector3 UnkCoordinates;
    FloatVector4 UnkAngle;
} CSPlayerCoords;

// CSNetMan
// CS::CSNetMan ()
// Length 0x20004
typedef struct {
    uint32 unk0x0 <hidden = true>;
    Assert(unk0x0 == 2);
    byte CSNetManData[0x20000];
} CSNetMan<size=0x20004>;

local enum <uint16> WeatherTypeEnum {
    None2 = -1,
    Default = 0,
    Rain = 20,
    Snow = 40,
    WindyRain = 30,
    Fog = 50,
    Cloudless = 1,
    FlatClouds = 10,
    PuffyClouds = 11,
    RainyCloud = 21,
    WindyFog = 31,
    HeavySnow = 41,
    HeavyFog = 51,
    WindyPuffyClouds = 60,
    RainyHeavyFog = 52,
    SnowyHeavyFog = 81,
    ScatteredRain = 82,
    Unknown18 = 83,
    Unknown19 = 84,
    Unknown20 = 85,
    Unknown21 = 86,
    Unknown22 = 87,
    Unknown23 = 88,
};
// WorldAreaWeather
// CS::WorldAreaWeather 
// Length 0xC
typedef struct {
    uint16 AreaId;
    WeatherTypeEnum WeatherType;
    // Maybe a timer?
    uint32 Timer;
    uint32 padding <hidden = true>;
} CSWorldAreaWeather<size=0xC>;

// WorldAreaTime
// CS::WorldAreaTime
// Length 0xC
typedef struct {
    uint32 Hour;
    uint32 Minute;
    uint32 Seconds;
} CSWorldAreaTime <read=Str("%02d:%02d:%02d", Hour, Minute, Seconds)>;

typedef struct {
    int BaseVersionCopy;
    int BaseVersion;
    Boolean BaseVersionIsLatest;
    Assert( BaseVersionIsLatest == True || BaseVersionIsLatest == False);
    int unk0xc <hidden = true>;
} BaseVersion;

typedef struct {
    uint64 unk0x0;
    uint64 unk0x8;
    uint64 unk0x10;
    uint64 unk0x18;
    uint64 unk0x20;
    uint32 unk0x28;
    uint32 unk0x2c;
    uint32 unk0x30;
    uint64 unk0x34;
    uint32 unk0x3c;
} CSPS5Activity <size = 0x20>;

typedef struct {
    uint64 unk0x0;
    uint64 unk0x8;
    uint64 unk0x10;
    uint64 unk0x18;
    uint64 unk0x20;
    uint64 unk0x28;
    uint16 unk0x30;
} CSDlc;

typedef struct (PlayerGameData &player) {
    // Var1 = PlayerLevel + 1;
    // Var2 = Var1 * 4;
    // (Var1 | ((Var2 / 0xfff1) * 0xf + Var2) * 0x10000) * 2
    uint32 Level <format = hex>;
    local uint var1 = player.Level + 1;
    local uint var2 = var1 * 4;
    Assert(Level == (var1 | ((var2 / 0xfff1) * 0xf + var2) * 0x10000) * 2);
} WeirdPlayerGameData <size = 0x80>;

// CSMenuSystemSaveLoad
// CS::CSMenuSystemSaveLoad (7FF4A00859D0)
// Length 0x3D
typedef struct {
    uint32 unk;
    uint32 size;
    byte data[size]; 
} CSMenuSystemSaveLoad;

// CSProfileSummary
// CS::CSProfileSummary (7FF4A0087EE0)
// Length ??
typedef struct {
    wchar_t chracter_name[0x11];
    int32 level;
    int32 _0x28;
    int32 _0x2C;
    int32 _0x30;
    int32 _0x34;
    int32 _0x38_0x150;
    byte _0x38_0x8[0x120];
    uint32 _0xE8[0x3A] <format=hex>;
    byte _0x290;
    byte _0x291;
    byte _0x292;
    byte _0x293;
    byte _0x294;
    byte _0x295;
    int32 _0x298;
} CSProfileSummary;

// PCOptionsData
// CS::PCOptionsData (7FF49E1830C0)
// Length ??
typedef struct {
    uint16 _0x8[0x9];
    byte _0x1a[0xa0];
} PCOptionsData;

// CSKeyConfigSaveLoad
// CS::CSKeyConfigSaveLoad (7FF49E1830C0)
// Length ??
typedef struct {
    uint32 unk;
    uint32 size;
    byte data[size];
} CSKeyConfigSaveLoad;

struct BND4FileHeader {
    char magic[0x4];
    byte unk[0x5];
    byte big_endian;
    byte unk;
    byte unk;
    uint file_count;
} Header <size=0x300>;

// Character Slot
struct Slot {
    // Checksum
    byte checksum[0x10] <hidden = true>;
    
    // Patch version?
    uint32 Version;
    
    // MapID
    M MapID;
    
    // Random bytes? Game called random generator on this I think :thinkus:
    byte unk0x8[0x18]<hidden=true>;
    
    // GaitemMap count. It's two entries shorter on older patches.
    local int count = 0x1400;
    if ( Version <= 80 ) {
        count = 0x13FE; 
    }
    
    // Gaitem Map
    Item GaitemHandleMap[count] <optimize=false, read=Str("%X -> %X", this.GaitemHandle, this.ItemID)>;
    
    // Player Data
    PlayerGameData Player;
    SPEffects SpEffects[0xd] <read=Str("%d", this.SPEffectID)>;
    
    // Equipment and Inventory Data
    ChrAsmEquipment EquippedItemsEquipIndex;
    ArmStyleAndActiveWeaponSlots ActiveEquippedWeaponSlots;
    ChrAsmEquipment EquippedItemsItemIds;
    DisplayFormatHex();
    ChrAsmEquipment EquippedItemsGaitemHandles;
    DisplayFormatDecimal();
    Inventory InventoryHeld(0xA80, 0x180);
    EquipMagicData EquippedSpells;
    EquipItemData EquippedItems;
    GestureEquipData EquippedGestures;
    EquipProjectileData AcquiredProjectiles;
    EquippedArmamentsAndItems EquippedArmamentsandItems;
    PhysicEquipData EquippedPhysics;
    
    // Face Data
    FaceData Facedata;
    
    // Inventory Data (Storage Box)
    Inventory InventoryStorageBox(0x780, 0x80);
    
    // Gestures
    GestureGameData Gestures;
    
    // Regions
    Regions UnlockedRegions;
    
    // Horse
    RideGameData Horse;
    
    // Control Byte
    byte one <hidden=true>;
    Assert(one == 1 || one == 0);
    
    // Bloodstain
    BloodStainData BloodStain;
    
    uint32 unk_gameDataMan_0x120_or_gameDataMan_0x130 <hidden = true>;
    uint32 unk_gameDataMan_0x88 <hidden = true>;
    
    // MenuProfileSaveLoad
    MenuProfileSaveLoad UnkMenuProfileSaveLoad;
    
    // TrophyEquipData
    TrophyEquipData UnkTrophyEquipData <hidden = true>;
    
    // GaitemGameData
    GaitemGameData GaitemData;
    
    // TutorialData
    CSTutorialData TutorialData;
    
    // Some kind of indicator, stops the game from saving if set to 1
    byte GlobalGameMan_0x8c <hidden = true>;
    
    // TODO: Figure these
    byte GlobalGameMan_0x8d <hidden = true>;
    byte GlobalGameMan_0x8e <hidden = true>;
    
    // Total times player dies since character was first created
    uint32 TotalDeathsCount;
    
    // Character Type
    local enum CT { None = -1, Phantom = 1,  Invader = 2, Ghost = 3, DeadGhost = 10, NakedGhost = 11, Unkown = 13, NakedGhost2 = 14, Invader2 = 15, Invader3 = 16, Blue = 17, Invader4 = 18 };
    CT ChracterType;
    
    // Setting to 1 means can't warp, rest in sites of graces, etc...
    byte InOnlineSessionFlag;
    
    // For phantom or invader character types this value is 0. Otherwise it's 8.
    uint32 OnlineCharacterTypeFlag;
    Assert(OnlineCharacterTypeFlag == 0 || OnlineCharacterTypeFlag == 8);
    
    // Last Grace Rested (-1000)
    uint32 LastRestedGrace;
    
    // Not Alone Flag
    byte NotAloneFlag;
    
    // 1 = 10 seconds. 
    uint32 InGameTimer;
    
    uint32 unk_gameDataMan_0x124_or_gameDataMan_0x134 <hidden = true>;
    
    // EventFlags
    EventFlag EventFlags[0x1BF99F] <name = Str("Offset"), read=Str("%d,%d,%d,%d,%d,%d,%d,%d", Bit0, Bit1, Bit2, Bit3, Bit4, Bit5, Bit6, Bit7)>; 
    byte EventFlagTerminator <hidden = true>;
    Assert(EventFlagTerminator == 0);
    
    // Sized Data?
    CSFieldArea FieldArea; 
    CSWorldArea WorldArea;
    CSWorldGeomMan WorldGeom;
    CSWorldGeomMan WorldGeom2;
    CSRendMan RendMan;
    
    // Player Coordinates
    CSPlayerCoords PlayerCoordinates;
    
    // So far testing shows that setting this to 1 makes you spawn in with animation, 0 means not
    byte GameMan_0xB5E <hidden = true>;
    
    // So far testing shows this gets set to 1 when you map warp, but is set to 0 after you rest at grace
    byte GameMan_0xB5F <hidden = true>;
    
    // SpawnPointEntityId
    uint32 SpawnPointEntityId;
    
    // It's with a heavy heart that I have make an ass out of you and me and assert this as zero without being sure.
    uint32 GameMan0xb64 <hidden = true>;
    Assert(GameMan0xb64 == 0);
    
    // Only saved on versions post patch 65. Temporarily holds SpawnEntityId - 970.
    if (Version > 65) {
        uint32 TempSpawnPointEntityId;
    }
    
     // Only saved on versions post patch 66. Temporarily `1` during loading screen.
    if (Version > 66) {
        byte GameMan0xCB3 <hidden = true>;
    }
    
    // Todo: Detail this
    CSNetMan NetMan;
    
    // World Area Weather
    CSWorldAreaWeather WorldAreaWeather;
    CSWorldAreaTime WorldAreaTime;
    
    // Version from when the character was created.
    BaseVersion BaseCharacterVersion;
    uint64 SteamId;
    
    CSPS5Activity PS5Activity;
    
    CSDlc DLC;
    
    WeirdPlayerGameData PlayerGameData2 (Player);
} Character[10] <optimize=false, size=0x280010, read=Str("%03d | %s", this.Player.Level, this.Player.CharacterName)>;

struct USER_DATA10{
    byte Checksum[0x10] <hidden = true>;
    uint32 unk;
    uint64 steam_id;
    byte unk2[0x140];
    CSMenuSystemSaveLoad cs_menu_system_save_load;
    byte active_slot[0xA];
    CSProfileSummary profile_summary[0xA];
    uint32 _0xd0;
    byte unk;
    PCOptionsData pc_option_data;
    CSKeyConfigSaveLoad cs_key_config_save_load;
    uint64 _0x118;
} Common <size=0x60010>;

struct USER_DATA11{
    byte checksum[0x10] <hidden = true>;
    byte unk[0x10] <hidden = true>;
    byte Regulation[0x1e9fb0];
} Regulation<size=0x24001F>;

